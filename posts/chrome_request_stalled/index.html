<!DOCTYPE html>
<html lang ="en-US">
  <head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<link rel="stylesheet" href=../../css/brutalist-minimalist-variables.css>

<link rel="stylesheet" href="../../css/brutalist-minimalist.css">



<link rel="stylesheet" type="text/css" href="../../css/bm-responsiveness.css">


<link rel="stylesheet" href="../../css/beyond-minimalism.css">


<link rel="stylesheet" href=../../css/brutalist-minimalist-fonts.css>



<link rel="stylesheet" href="../../css/bm-printing.css" media="print">


<link rel="stylesheet" href="../../css/custom.css">
<link rel="alternate" type="text/gemini" href="gemini://xangelo.ca/gemini/posts/chrome_request_stalled/index.gmi" title="Xangelo.ca" />
<title>
Chrome HTTP Request stuck in &#34;Stalled&#34; State | Xangelo.ca
</title>
  </head>
  <body leftmargin=40 rightmarin=40>
    

<header>
  

<input id="menu-toggle" type="checkbox" hidden /><div id="nav-area"><label id='menu-button' for="menu-toggle"></label><nav id="nav-menu">
<a href="../../">Home</a>
<a href="../../tags/">All Categories</a>
<a href="../../page/about">About</a>
<a href="../../index.xml"><img src="../../icons/feed-icon-14x14.png"></a>
</nav>
</div>




  <h1><a href=../../>Xangelo.ca</a></h1>
  <em id="subtitle">Technical musings and other tidbits</em>  
</header>


    <main>
      
<h2>Chrome HTTP Request stuck in &#34;Stalled&#34; State</h2>

<div class="tag-list">
  
  [ <a href="../../tags/chrome">chrome</a> ]
  
  [ <a href="../../tags/investigation">investigation</a> ]
  
  [ <a href="../../tags/explanation">explanation</a> ]
  
</div>


<p>I got the chance to investigate a really odd bug where randomly network requests in Chrome would just hang. This would only occurr in our test environments at work and not in production. The request would hang for some long amount of time.. and then eventually complete successfully. The bug has been occurring for some time, but has been getting worse in Chrome. It got so bad that it was guaranteed that if you were using Chrome it was going to happen to you. Eventually it started happening in Firefox as well.. during an investor demo (what good is a demo if it doesn&rsquo;t go up in flames?). That&rsquo;s when I got roped in.</p>
<p>The first thing I did was attempt to replicate it and capture a <code>.har</code> file that I could share with anyone else that was interested. This part was easy - just popping open the network tab, navigating to the app on a test env, and then clicking every link that would trigger a network request. After about 30-40 seconds I had replicated the event</p>
<p><img src="../../img/http2/wait-queue.png" alt="Stuck Stalled&hellip;"></p>
<p>So we can clearly see here that the request took 2 minutes and the entirety of that time the connection was stuck in the <code>stalled</code> state. That indicates one of two things:</p>
<ol>
<li>
<p>Chrome never attempted to make the network request at all. Perhaps the priority on the request was dropped, maybe there were too many connections open to that FQDN already. </p>
</li>
<li>
<p>In some situations chrome actually merges the CORS preflight requests into what it reports as <code>stalled</code>. So it&rsquo;s possible that there was a problem in the preflight request that caused the delay before the actual request happened.</p>
</li>
</ol>
<p>I did a bit more testing to figure out the scope of the issue. On/Off VPN with multiple browsers would all replicate the problem just fine. In this particular situation the fact that we could replicate it across EVERYTHING made it pretty clear that it was something related to our server.. but what? If the request never actually hits the server what could be going on?</p>
<h3 id="chrome-network-log">Chrome Network Log</h3>
<p>One tool that chrome has to diagnose networking issues is hidden away at <code>chrome://net-export</code>. It generates a very VERY detailed log of everything network related that chrome is aware of. </p>
<p><img src="../../img/http2/net-export.png" alt="Chrome Net Export"></p>
<p>I unchecked the <code>strip private information</code> option and told it to include cookies + credentials and started logging it to disk. Then I swapped back to my tab and replicated the issue. Waited a few seconds, and then went back and ended the capture session.</p>
<p>Once you get that capture file, you have to head over to <a href="https://netlog-viewer.appspot.com">https://netlog-viewer.appspot.com</a> and import it. There&rsquo;s a TON of information here, and honestly I didn&rsquo;t even look at half of it. The only two things I cared about were the &ldquo;Events&rdquo; and &ldquo;Timeline&rdquo; sections. The Timeline really makes no sense until you have a idea of when your actual network event happened, so we can skip that and jump right over to Events</p>
<p>There will likely be a lot of events. The &ldquo;filter&rdquo; at the top never worked for me given the sheer size of the events.. but scrolling through them all was just fine and eventually I found the URL request that caused the issue. If you click on the event it will display a bunch of debug information about the request. </p>
<p><img src="../../img/http2/event-169281.png" alt="Event 168281"></p>
<p>As you can see.. suddenly there&rsquo;s a HUGE jump in time from <code>66807</code> to <code>187631</code>. We&rsquo;ve confirmed now that this is a problem that&rsquo;s occurring within the CORS preflight request specifically, and it&rsquo;s just getting rolled into the <code>stalled</code> state. The log viewer makes it trivial to dig down into the events and if you click on the details of the <code>HTTP_STREAM_JOB_CONTROLLER</code> event you can see some more details. </p>
<p><img src="../../img/http2/event-169284.png" alt="Event 169283"></p>
<p>Here again, we see that there is a definitely delay when it attempts to call <code>HTTP_STREAM_REQUEST_STARTED_JOB</code> </p>
<p><img src="../../img/http2/event-169284.png" alt="Event 169284"></p>
<p>And now we can easily see the problem: <code>SOCKET_POOL_STALLED_MAX_SOCKETS_PER_GROUP</code></p>
<p>In HTTP1.1 each tab in your browser is configured to only make a certain number of requests per FQDN at the same time.This is one of the reasons why we load &ldquo;static assets&rdquo; on a different subdomain. By loading static assets on a separate FQDN we can increase the objects that are simultaneously loaded in our tab providing a better experience (for some definition of experience) to our user. In HTTP2, this restriction is across every single tab in your browser. For chrome, it can only instantiate 6 concurrent connections to an FQDN. This is because your connections are persistent in http2 and you don&rsquo;t need to deal with the initialization handshakes on every request. The connection, once opened, is continually reused. </p>
<p><span style="font-family: sans-serif; font-size: 16px; font-style: normal; font-variant-caps: normal;">For some reason, the socket pool dedicated to this particular FQDN gets filled up and so it can&rsquo;t actually make the next request. So it just sits there.. until suddenly a socket is available (2 minutes later) and it is able to complete the rest of the request as expected. The &ldquo;suddenly&rdquo; is likely due to the default socket timeout. Once that timeout is hit, Chrome kills the connection and opens a new one and suddenly our request works again.</span><br></p>
<p>We can dig even further! Since we know that this is happening on an HTTP2 call, we can filter our events to only show us the http2 connections and that paints a more serious picture! </p>
<p><img src="../../img/http2/goaway.png" alt="GOAWAY"></p>
<p>Every one of our http2 sockets is getting sent a <code>GOAWAY</code> frame by the server.. but notice that it says <code>NO_ERROR</code>. This generally indicates that the server is telling the client that it will be shutting down this socket and. The <code>GOAWAY</code> frame also tells the client what the last stream that it processed was. This is so that the client can resend any data that it needs to on a new connection. What should happen is that after this frame, the connection is ended by both parties and we move on to a new one. In practice, it happens after a following <code>GOAWAY</code> frame that indicates the connection is now dead. Except that final disconnect frame is never sent. So as far as chrome is concerned, we&rsquo;re still happily connected so it returns the connection to the pool. But the server has disconnected.</p>
<p>So it just sits there trying to use the connection again, times out, and then closes and opens a new connection! And so we tracked down the mysterious slow-down and also used some cool tools in the process! </p>
<hr>
<p>One thing I do want to note: This seems like a really straight forward problem - but that&rsquo;s just in hindsight. In the moment there&rsquo;s lots of googling and staring off into space trying to remember obscure keywords. I have a really bad memory, and so one of the things I do is memorize keywords/ideas rather than content because there&rsquo;s just too much to remember. In this way I can ensure that I can find the pieces of information I need when I need to. In this case the keys things were:  </p>
<ul>
<li>
<p>chrome has some kind of detailed network log</p>
</li>
<li>
<p>browsers like to fold CORS requests into the main request for reporting</p>
</li>
<li>
<p>http2 has a max connection limit across your browser</p>
</li>
</ul>
<p>The rest of the information used is all derivable from those keys and a search engine.</p>

<div class="post-date">
  Posted Tuesday, June 20, 2023
</div>

    </main>
    
<footer>





  <span id="footer-links">
[<a href="https://github.com/angelor">GitHub</a>]
[<a href="https://git.xangelo.ca">GitWeb</a>]
[<a href="https://www.linkedin.com/in/rodriguesangelo">Linked In</a>]
</span>
</footer>





<p id="source-url">Source: <a href=../../posts/chrome_request_stalled/>https://xangelo.ca/posts/chrome_request_stalled/</a>, 2023-06-20</p>



</body>
     
 
